anchor upgrade --program-id ehzTTCgmtXwK1GyHZRRnte4Rdt1yTvrvG635M76RPfm ./target/deploy/token_presale.so
solana address -k ./target/deploy/token_presale-keypair.json

ehzTTCgmtXwK1GyHZRRnte4Rdt1yTvrvG635M76RPfm


anchor-lang = {version = "0.26.0", features = ["init-if-needed"]}

#[account(init_if_needed, payer = <target_account>)]

#[account(init_if_needed, payer = <target_account>, space = <num_bytes>)]	Exact same functionality as the init constraint but only runs if the account does not exist yet.
If the account does exist, it still checks whether the given init constraints are correct, e.g. that the account has the expected amount of space and, if it's a PDA, the correct seeds etc.

This feature should be used with care and is therefore behind a feature flag. You can enable it by importing anchor-lang with the init-if-needed cargo feature.
When using init_if_needed, you need to make sure you properly protect yourself against re-initialization attacks. You need to include checks in your code that check that the initialized account cannot be reset to its initial settings after the first time it was initialized (unless that it what you want).
Because of the possibility of re-initialization attacks and the general guideline that instructions should avoid having multiple execution flows (which is important so they remain easy to understand), consider breaking up your instruction into two instructions - one for initializing and one for using the account - unless you have a good reason not to do so.

Example:
#[account]
#[derive(Default)]
pub struct MyData {
    pub data: u64
}

#[account]
pub struct OtherData {
    pub data: u64
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init_if_needed, payer = payer)]
    pub data_account: Account<'info, MyData>,
    #[account(init_if_needed, payer = payer, space = 8 + 8)]
    pub data_account_two: Account<'info, OtherData>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>
}